import * as vscode from "vscode";
import * as fs from "fs/promises";
import * as path from "path";
import * as dotenv from "dotenv";
dotenv.config({ path: path.join(__dirname, "../.env") });

let captioner: any;

export async function activate(context: vscode.ExtensionContext) {
	vscode.window.showInformationMessage("!!!Easy Alt Extension Activated!");

	const HfInference = (await import("@huggingface/inference")).HfInference;

	const hfToken = process.env.HF_TOKEN;
	captioner = new HfInference(hfToken);

	// Add validation before using it:
	if (!hfToken) {
		vscode.window.showErrorMessage(
			"HF_TOKEN environment variable is not set. Please set it to use Easy Alt."
		);
		return;
	}

	try {
		await initializeModel(context.globalStorageUri);
		vscode.window.showInformationMessage(
			"Image captioning model initialized successfully."
		);
	} catch (error) {
		vscode.window.showErrorMessage(
			`Failed to initialize image captioning model: ${error}`
		);
		return;
	}

	const provider = vscode.languages.registerCompletionItemProvider(
		["html", "jsx", "tsx"],
		{
			async provideCompletionItems(
				document: vscode.TextDocument,
				position: vscode.Position
			) {
				const lineText = document.lineAt(position).text;
				const linePrefix = lineText.substring(0, position.character);

				if (!linePrefix.includes('alt="') && !linePrefix.includes("alt='")) {
					return undefined;
				}

				const imgRegex = /<img[^>]*src=["']([^"']+)["'][^>]*>/;
				const imgMatch = lineText.match(imgRegex);

				if (imgMatch) {
					const src = imgMatch[1];
					let imageBuffer: Buffer;

					try {
						let imagePath;
						if (isRemoteUrl(src)) {
							imageBuffer = await downloadImage(src);
						} else {
							const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
							if (!workspaceFolder) {
								throw new Error("No workspace folder found.");
							}
							const cleanSrc = src.replace(/^[./]+/, "");
							imagePath = path.resolve(workspaceFolder.uri.fsPath, cleanSrc);
							imageBuffer = await fs.readFile(imagePath);
						}

						const caption = await generateCaption(imageBuffer);

						const completion = new vscode.CompletionItem(
							caption,
							vscode.CompletionItemKind.Value
						);
						completion.insertText = caption;
						completion.detail = "AI Generated Alt Text";

						const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
						const imageUrl = isRemoteUrl(src)
							? src
							: vscode.Uri.file(imagePath!).toString();

						completion.documentation = new vscode.MarkdownString(
							`<img src="${imageUrl}" width="200" style="max-width: 100%; height: auto;">\n\nPreview: ${caption}\n\n*Generated by Easy Alt*`
						);
						completion.documentation.baseUri = workspaceFolder
							? vscode.Uri.file(workspaceFolder.uri.fsPath)
							: undefined;
						completion.documentation.supportHtml = true;
						completion.documentation.isTrusted = true;

						return [completion];
					} catch (error) {
						vscode.window.showErrorMessage(`Error processing image: ${error}`);
						return undefined;
					}
				}

				return undefined;
			},
		},
		'"',
		"'"
	);

	let disposable = vscode.commands.registerCommand(
		"easy-alt.generateAlt",
		() => {
			const editor = vscode.window.activeTextEditor;
			if (!editor) {
				return;
			}
			vscode.commands.executeCommand("editor.action.triggerSuggest");
		}
	);

	context.subscriptions.push(provider, disposable);
}

async function initializeModel(storagePath: vscode.Uri): Promise<void> {}

async function generateCaption(imageBuffer: Buffer): Promise<string> {
	if (!captioner) {
		throw new Error("Image captioning model not initialized.");
	}

	try {
		// Ensure imageBuffer is a Buffer instance
		if (!(imageBuffer instanceof Buffer)) {
			throw new Error("Invalid image data: not a Buffer");
		}

		const result = await captioner.imageToText({
			data: imageBuffer,
			model: "Salesforce/blip-image-captioning-base",
		});

		console.log("RESSSS", result);

		if (!result) {
			throw new Error("Unexpected response from image captioning model");
		}

		return result.generated_text;
	} catch (error) {
		console.error("Error in generateCaption:", error);
		throw error;
	}
}

function isRemoteUrl(url: string): boolean {
	return url.startsWith("http://") || url.startsWith("https://");
}

async function downloadImage(url: string): Promise<Buffer> {
	try {
		const response = await fetch(url);
		if (!response.ok) {
			throw new Error(
				`Failed to download image: ${response.status} ${response.statusText}`
			);
		}
		const arrayBuffer = await response.arrayBuffer();
		return Buffer.from(arrayBuffer);
	} catch (error) {
		console.error("Error in downloadImage:", error);
		throw error;
	}
}

export function deactivate() {}
